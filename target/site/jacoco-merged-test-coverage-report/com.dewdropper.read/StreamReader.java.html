<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamReader.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">dewdropper</a> &gt; <a href="index.source.html" class="el_package">com.dewdropper.read</a> &gt; <span class="el_source">StreamReader.java</span></div><h1>StreamReader.java</h1><pre class="source lang-java linenums">package com.dewdropper.read;

import com.dewdropper.structure.NoStreamException;
import com.dewdropper.structure.datastore.StreamStore;
import com.dewdropper.structure.events.Event;
import com.dewdropper.structure.events.ReadEventData;
import com.dewdropper.structure.events.StreamReadResults;
import com.dewdropper.structure.read.Direction;
import com.dewdropper.structure.read.ReadRequest;
import com.dewdropper.structure.serialize.EventSerializer;
import com.dewdropper.utils.WaitUntilUtils;
import java.util.Optional;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.BooleanSupplier;
import java.util.function.Consumer;
import lombok.Data;
import lombok.extern.log4j.Log4j2;

<span class="nc bnc" id="L20" title="All 66 branches missed.">@Data</span>
<span class="nc" id="L21">@Log4j2</span>
public class StreamReader {
    private static final int READ_PAGE_SIZE = 500;
<span class="nc" id="L24">    protected AtomicLong streamPosition = new AtomicLong(0L);</span>
<span class="nc" id="L25">    protected boolean firstEventRead = false;</span>
<span class="nc" id="L26">    protected String streamName;</span>
<span class="nc" id="L27">    protected StreamDetails streamDetails;</span>

<span class="nc" id="L29">    private StreamStore streamStoreConnection;</span>
<span class="nc" id="L30">    private Class&lt;?&gt; eventType;</span>
<span class="nc" id="L31">    private EventSerializer serializer;</span>
<span class="nc" id="L32">    private Consumer&lt;Event&gt; onEvent;</span>

<span class="nc" id="L34">    public StreamReader(StreamStore connection, EventSerializer serializer, Consumer&lt;Event&gt; onEvent, StreamDetails streamDetails, Class&lt;?&gt; eventType) {</span>
<span class="nc" id="L35">        this.streamStoreConnection = connection;</span>
<span class="nc" id="L36">        this.eventType = eventType;</span>
<span class="nc" id="L37">        this.serializer = serializer;</span>
<span class="nc" id="L38">        this.onEvent = onEvent;</span>
<span class="nc" id="L39">        this.streamDetails = streamDetails;</span>
<span class="nc" id="L40">        this.streamName = streamDetails.getStreamName();</span>
<span class="nc" id="L41">    }</span>

    public boolean read(Long checkpoint, Long count, Direction direction) throws NoStreamException {
<span class="nc bnc" id="L44" title="All 4 branches missed.">        if (checkpoint != null &amp;&amp; checkpoint &lt; 0) { throw new IllegalArgumentException(&quot;A negative checkpoint:&quot; + checkpoint + &quot; is not allowed&quot;); }</span>

<span class="nc bnc" id="L46" title="All 4 branches missed.">        if (count != null &amp;&amp; count &lt; 1) { throw new IllegalArgumentException(&quot;A non positive count:&quot; + count + &quot; is not allowed&quot;); }</span>

<span class="nc bnc" id="L48" title="All 2 branches missed.">        if (!validateStreamName(streamName)) { throw new NoStreamException(streamName); }</span>

<span class="nc" id="L50">        this.firstEventRead = false;</span>
<span class="nc" id="L51">        direction = Optional.ofNullable(direction).orElse(Direction.FORWARD);</span>
<span class="nc bnc" id="L52" title="All 2 branches missed.">        long sliceStart = Optional.ofNullable(checkpoint).orElse(direction == Direction.FORWARD ? -1L : 0L);</span>
<span class="nc" id="L53">        long remaining = Optional.ofNullable(count).orElse(Long.MAX_VALUE);</span>
        StreamReadResults readResults;
        do {
<span class="nc bnc" id="L56" title="All 2 branches missed.">            long page = remaining &lt; READ_PAGE_SIZE ? remaining : READ_PAGE_SIZE;</span>

<span class="nc" id="L58">            ReadRequest request = new ReadRequest(streamName, sliceStart, page, direction);</span>
<span class="nc" id="L59">            readResults = streamStoreConnection.read(request);</span>

<span class="nc" id="L61">            this.firstEventRead = true;</span>
<span class="nc" id="L62">            remaining -= readResults.getEvents().size();</span>
<span class="nc" id="L63">            sliceStart = readResults.getNextEventNumber();</span>

<span class="nc" id="L65">            readResults.getEvents().forEach(eventRead());</span>

<span class="nc bnc" id="L67" title="All 4 branches missed.">        } while (!readResults.isEndOfStream() &amp;&amp; remaining != 0);</span>
<span class="nc" id="L68">        return this.firstEventRead;</span>
    }

    boolean isReadComplete(BooleanSupplier completionCheck) {
<span class="nc bnc" id="L72" title="All 4 branches missed.">        if (this.firstEventRead &amp;&amp; completionCheck != null) {</span>
            try {
                // Is this right?
<span class="nc" id="L75">                WaitUntilUtils.waitUntil(completionCheck, 200);</span>
<span class="nc" id="L76">            } catch (TimeoutException e) {</span>
<span class="nc" id="L77">                log.error(&quot;Timeout! &quot;, e);</span>
<span class="nc" id="L78">                return true;</span>
<span class="nc" id="L79">            }</span>

<span class="nc" id="L81">            return true;</span>
        }
<span class="nc" id="L83">        return false;</span>
    }

    protected Consumer&lt;ReadEventData&gt; eventRead() {
<span class="nc" id="L87">        return recordedEvent -&gt; {</span>
            try {
                while (true) {
<span class="nc" id="L90">                    long existingValue = streamPosition.get();</span>
<span class="nc" id="L91">                    long newValue = recordedEvent.getEventNumber();</span>
<span class="nc bnc" id="L92" title="All 2 branches missed.">                    if (streamPosition.compareAndSet(existingValue, newValue)) {</span>
<span class="nc" id="L93">                        break;</span>
                    }
<span class="nc" id="L95">                }</span>

<span class="nc" id="L97">                this.firstEventRead = true;</span>

<span class="nc" id="L99">                Object event = serializer.deserialize(recordedEvent);</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                if (event instanceof Event) {</span>
<span class="nc" id="L101">                    onEvent.accept((Event) event);</span>
                }
<span class="nc" id="L103">            } catch (Exception e) {</span>
<span class="nc" id="L104">                log.error(&quot;problem reading event: &quot;, e);</span>
<span class="nc" id="L105">            }</span>

<span class="nc" id="L107">        };</span>
    }

    public boolean validateStreamName(String streamName) {
<span class="nc" id="L111">        StreamReadResults currentSlice = null;</span>
        try {
<span class="nc" id="L113">            ReadRequest request = new ReadRequest(streamName, 0L, 1L, Direction.FORWARD);</span>
<span class="nc" id="L114">            currentSlice = streamStoreConnection.read(request);</span>
<span class="nc" id="L115">        } catch (NoStreamException e) {</span>
<span class="nc" id="L116">            return false;</span>
<span class="nc" id="L117">        }</span>
<span class="nc bnc" id="L118" title="All 2 branches missed.">        return !(currentSlice.isEmpty());</span>
    }

    public Long getPosition() {
<span class="nc bnc" id="L122" title="All 2 branches missed.">        return this.firstEventRead ? this.streamPosition.get() : null;</span>
    }

    public NameAndPosition getNameAndPosition() throws NoStreamException {
<span class="nc" id="L126">        String simpleName = eventType.getSimpleName();</span>

<span class="nc" id="L128">        NameAndPosition nameAndPosition = NameAndPosition.builder().streamType(streamDetails.getStreamType()).name(streamDetails.getStreamName()).consumer(onEvent).messageType(eventType).create();</span>

        try {
<span class="nc" id="L131">            Long position = getPosition();</span>
<span class="nc" id="L132">            return nameAndPosition.completeTask(streamName, position);</span>
<span class="nc" id="L133">        } catch (NoStreamException e) {</span>
<span class="nc" id="L134">            throw e;</span>
<span class="nc" id="L135">        } catch (Exception e) {</span>
<span class="nc" id="L136">            log.error(&quot;There was a problem reading from: {} for: {}&quot;, streamName, simpleName, e);</span>
<span class="nc" id="L137">            return nameAndPosition;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>